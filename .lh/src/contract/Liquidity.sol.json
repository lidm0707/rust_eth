{
    "sourceFile": "src/contract/Liquidity.sol",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 9,
            "patches": [
                {
                    "date": 1733405990047,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733405996244,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,43 @@\n+// SPDX-License-Identifier: MIT\r\n+pragma solidity ^0.8.0;\r\n+\r\n+import \"./src/contract/IERC20.sol\";\r\n+\r\n+contract LiquidityPool {\r\n+    IERC20 public tokenA;\r\n+    IERC20 public tokenB;\r\n+    mapping(address => uint256) public liquidity;\r\n+\r\n+    uint256 public reserveA;\r\n+    uint256 public reserveB;\r\n+\r\n+    constructor(address _tokenA, address _tokenB) {\r\n+        tokenA = IERC20(_tokenA);\r\n+        tokenB = IERC20(_tokenB);\r\n+    }\r\n+\r\n+    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n+        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA += amountA;\r\n+        reserveB += amountB;\r\n+        liquidity[msg.sender] += (amountA + amountB);\r\n+    }\r\n+\r\n+    function removeLiquidity(uint256 shares) public {\r\n+        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n+        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n+\r\n+        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA -= amountA;\r\n+        reserveB -= amountB;\r\n+        liquidity[msg.sender] -= shares;\r\n+    }\r\n+\r\n+    function totalLiquidity() public view returns (uint256) {\r\n+        return reserveA + reserveB;\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1733406019739,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,43 @@\n+// SPDX-License-Identifier: MIT\r\n+pragma solidity ^0.8.0;\r\n+\r\n+import \"./IERC20.sol\";\r\n+\r\n+contract LiquidityPool {\r\n+    IERC20 public tokenA;\r\n+    IERC20 public tokenB;\r\n+    mapping(address => uint256) public liquidity;\r\n+\r\n+    uint256 public reserveA;\r\n+    uint256 public reserveB;\r\n+\r\n+    constructor(address _tokenA, address _tokenB) {\r\n+        tokenA = IERC20(_tokenA);\r\n+        tokenB = IERC20(_tokenB);\r\n+    }\r\n+\r\n+    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n+        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA += amountA;\r\n+        reserveB += amountB;\r\n+        liquidity[msg.sender] += (amountA + amountB);\r\n+    }\r\n+\r\n+    function removeLiquidity(uint256 shares) public {\r\n+        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n+        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n+\r\n+        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA -= amountA;\r\n+        reserveB -= amountB;\r\n+        liquidity[msg.sender] -= shares;\r\n+    }\r\n+\r\n+    function totalLiquidity() public view returns (uint256) {\r\n+        return reserveA + reserveB;\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1733406083825,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,43 @@\n+// SPDX-License-Identifier: MIT\r\n+pragma solidity ^0.8.0;\r\n+\r\n+import \"./IER20.sol.sol\";\r\n+\r\n+contract LiquidityPool {\r\n+    IERC20 public tokenA;\r\n+    IERC20 public tokenB;\r\n+    mapping(address => uint256) public liquidity;\r\n+\r\n+    uint256 public reserveA;\r\n+    uint256 public reserveB;\r\n+\r\n+    constructor(address _tokenA, address _tokenB) {\r\n+        tokenA = IERC20(_tokenA);\r\n+        tokenB = IERC20(_tokenB);\r\n+    }\r\n+\r\n+    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n+        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA += amountA;\r\n+        reserveB += amountB;\r\n+        liquidity[msg.sender] += (amountA + amountB);\r\n+    }\r\n+\r\n+    function removeLiquidity(uint256 shares) public {\r\n+        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n+        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n+\r\n+        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA -= amountA;\r\n+        reserveB -= amountB;\r\n+        liquidity[msg.sender] -= shares;\r\n+    }\r\n+\r\n+    function totalLiquidity() public view returns (uint256) {\r\n+        return reserveA + reserveB;\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1733406091920,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,43 @@\n+// SPDX-License-Identifier: MIT\r\n+pragma solidity ^0.8.0;\r\n+\r\n+import \"./IER20.sol\";\r\n+\r\n+contract LiquidityPool {\r\n+    IERC20 public tokenA;\r\n+    IERC20 public tokenB;\r\n+    mapping(address => uint256) public liquidity;\r\n+\r\n+    uint256 public reserveA;\r\n+    uint256 public reserveB;\r\n+\r\n+    constructor(address _tokenA, address _tokenB) {\r\n+        tokenA = IERC20(_tokenA);\r\n+        tokenB = IERC20(_tokenB);\r\n+    }\r\n+\r\n+    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n+        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA += amountA;\r\n+        reserveB += amountB;\r\n+        liquidity[msg.sender] += (amountA + amountB);\r\n+    }\r\n+\r\n+    function removeLiquidity(uint256 shares) public {\r\n+        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n+        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n+\r\n+        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA -= amountA;\r\n+        reserveB -= amountB;\r\n+        liquidity[msg.sender] -= shares;\r\n+    }\r\n+\r\n+    function totalLiquidity() public view returns (uint256) {\r\n+        return reserveA + reserveB;\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1733406597624,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,79 @@\n+// SPDX-License-Identifier: MIT\r\n+pragma solidity ^0.8.0;\r\n+\r\n+import \"./IERC20.sol\";\r\n+\r\n+contract LiquidityPool {\r\n+    IERC20 public tokenA;\r\n+    IERC20 public tokenB;\r\n+    mapping(address => uint256) public liquidity;\r\n+\r\n+    uint256 public reserveA;\r\n+    uint256 public reserveB;\r\n+\r\n+    constructor(address _tokenA, address _tokenB) {\r\n+        tokenA = IERC20(_tokenA);\r\n+        tokenB = IERC20(_tokenB);\r\n+    }\r\n+\r\n+    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n+        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA += amountA;\r\n+        reserveB += amountB;\r\n+        liquidity[msg.sender] += (amountA + amountB);\r\n+    }\r\n+\r\n+    function removeLiquidity(uint256 shares) public {\r\n+        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n+        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n+\r\n+        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA -= amountA;\r\n+        reserveB -= amountB;\r\n+        liquidity[msg.sender] -= shares;\r\n+    }\r\n+\r\n+    function swap(address tokenIn, uint256 amountIn) public returns (uint256 amountOut) {\r\n+        require(amountIn > 0, \"Input amount must be greater than zero\");\r\n+        require(\r\n+            tokenIn == address(tokenA) || tokenIn == address(tokenB),\r\n+            \"Invalid input token\"\r\n+        );\r\n+\r\n+        bool isTokenA = tokenIn == address(tokenA);\r\n+\r\n+        // Reserves of the input and output tokens\r\n+        uint256 reserveIn = isTokenA ? reserveA : reserveB;\r\n+        uint256 reserveOut = isTokenA ? reserveB : reserveA;\r\n+\r\n+        // Apply fee of 0.3% (997/1000)\r\n+        uint256 amountInWithFee = (amountIn * 997) / 1000;\r\n+        amountOut = (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);\r\n+\r\n+        require(amountOut > 0, \"Insufficient output amount\");\r\n+\r\n+        // Transfer the input token from the user to the pool\r\n+        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);\r\n+\r\n+        // Transfer the output token from the pool to the user\r\n+        IERC20 outputToken = isTokenA ? tokenB : tokenA;\r\n+        outputToken.transfer(msg.sender, amountOut);\r\n+\r\n+        // Update reserves\r\n+        if (isTokenA) {\r\n+            reserveA += amountIn;\r\n+            reserveB -= amountOut;\r\n+        } else {\r\n+            reserveB += amountIn;\r\n+            reserveA -= amountOut;\r\n+        }\r\n+    }\r\n+\r\n+    function totalLiquidity() public view returns (uint256) {\r\n+        return reserveA + reserveB;\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1733406666296,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,79 @@\n+// SPDX-License-Identifier: MIT\r\n+pragma solidity ^0.8.0;\r\n+\r\n+import \"./IER20.sol\";\r\n+\r\n+contract LiquidityPool {\r\n+    IERC20 public tokenA;\r\n+    IERC20 public tokenB;\r\n+    mapping(address => uint256) public liquidity;\r\n+\r\n+    uint256 public reserveA;\r\n+    uint256 public reserveB;\r\n+\r\n+    constructor(address _tokenA, address _tokenB) {\r\n+        tokenA = IERC20(_tokenA);\r\n+        tokenB = IERC20(_tokenB);\r\n+    }\r\n+\r\n+    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n+        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA += amountA;\r\n+        reserveB += amountB;\r\n+        liquidity[msg.sender] += (amountA + amountB);\r\n+    }\r\n+\r\n+    function removeLiquidity(uint256 shares) public {\r\n+        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n+        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n+\r\n+        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA -= amountA;\r\n+        reserveB -= amountB;\r\n+        liquidity[msg.sender] -= shares;\r\n+    }\r\n+\r\n+    function swap(address tokenIn, uint256 amountIn) public returns (uint256 amountOut) {\r\n+        require(amountIn > 0, \"Input amount must be greater than zero\");\r\n+        require(\r\n+            tokenIn == address(tokenA) || tokenIn == address(tokenB),\r\n+            \"Invalid input token\"\r\n+        );\r\n+\r\n+        bool isTokenA = tokenIn == address(tokenA);\r\n+\r\n+        // Reserves of the input and output tokens\r\n+        uint256 reserveIn = isTokenA ? reserveA : reserveB;\r\n+        uint256 reserveOut = isTokenA ? reserveB : reserveA;\r\n+\r\n+        // Apply fee of 0.3% (997/1000)\r\n+        uint256 amountInWithFee = (amountIn * 997) / 1000;\r\n+        amountOut = (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);\r\n+\r\n+        require(amountOut > 0, \"Insufficient output amount\");\r\n+\r\n+        // Transfer the input token from the user to the pool\r\n+        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);\r\n+\r\n+        // Transfer the output token from the pool to the user\r\n+        IERC20 outputToken = isTokenA ? tokenB : tokenA;\r\n+        outputToken.transfer(msg.sender, amountOut);\r\n+\r\n+        // Update reserves\r\n+        if (isTokenA) {\r\n+            reserveA += amountIn;\r\n+            reserveB -= amountOut;\r\n+        } else {\r\n+            reserveB += amountIn;\r\n+            reserveA -= amountOut;\r\n+        }\r\n+    }\r\n+\r\n+    function totalLiquidity() public view returns (uint256) {\r\n+        return reserveA + reserveB;\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1733406674244,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,79 @@\n+// SPDX-License-Identifier: MIT\r\n+pragma solidity ^0.8.0;\r\n+\r\n+import \"./IERC20.sol\";\r\n+\r\n+contract LiquidityPool {\r\n+    IERC20 public tokenA;\r\n+    IERC20 public tokenB;\r\n+    mapping(address => uint256) public liquidity;\r\n+\r\n+    uint256 public reserveA;\r\n+    uint256 public reserveB;\r\n+\r\n+    constructor(address _tokenA, address _tokenB) {\r\n+        tokenA = IERC20(_tokenA);\r\n+        tokenB = IERC20(_tokenB);\r\n+    }\r\n+\r\n+    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n+        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA += amountA;\r\n+        reserveB += amountB;\r\n+        liquidity[msg.sender] += (amountA + amountB);\r\n+    }\r\n+\r\n+    function removeLiquidity(uint256 shares) public {\r\n+        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n+        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n+\r\n+        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA -= amountA;\r\n+        reserveB -= amountB;\r\n+        liquidity[msg.sender] -= shares;\r\n+    }\r\n+\r\n+    function swap(address tokenIn, uint256 amountIn) public returns (uint256 amountOut) {\r\n+        require(amountIn > 0, \"Input amount must be greater than zero\");\r\n+        require(\r\n+            tokenIn == address(tokenA) || tokenIn == address(tokenB),\r\n+            \"Invalid input token\"\r\n+        );\r\n+\r\n+        bool isTokenA = tokenIn == address(tokenA);\r\n+\r\n+        // Reserves of the input and output tokens\r\n+        uint256 reserveIn = isTokenA ? reserveA : reserveB;\r\n+        uint256 reserveOut = isTokenA ? reserveB : reserveA;\r\n+\r\n+        // Apply fee of 0.3% (997/1000)\r\n+        uint256 amountInWithFee = (amountIn * 997) / 1000;\r\n+        amountOut = (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);\r\n+\r\n+        require(amountOut > 0, \"Insufficient output amount\");\r\n+\r\n+        // Transfer the input token from the user to the pool\r\n+        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);\r\n+\r\n+        // Transfer the output token from the pool to the user\r\n+        IERC20 outputToken = isTokenA ? tokenB : tokenA;\r\n+        outputToken.transfer(msg.sender, amountOut);\r\n+\r\n+        // Update reserves\r\n+        if (isTokenA) {\r\n+            reserveA += amountIn;\r\n+            reserveB -= amountOut;\r\n+        } else {\r\n+            reserveB += amountIn;\r\n+            reserveA -= amountOut;\r\n+        }\r\n+    }\r\n+\r\n+    function totalLiquidity() public view returns (uint256) {\r\n+        return reserveA + reserveB;\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1733406688414,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,79 @@\n+// SPDX-License-Identifier: MIT\r\n+pragma solidity ^0.8.0;\r\n+\r\n+import \"./IERC20.sol\";\r\n+\r\n+contract LiquidityPool {\r\n+    IERC20 public tokenA;\r\n+    IERC20 public tokenB;\r\n+    mapping(address => uint256) public liquidity;\r\n+\r\n+    uint256 public reserveA;\r\n+    uint256 public reserveB;\r\n+\r\n+    constructor(address _tokenA, address _tokenB) {\r\n+        tokenA = IERC20(_tokenA);\r\n+        tokenB = IERC20(_tokenB);\r\n+    }\r\n+\r\n+    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n+        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA += amountA;\r\n+        reserveB += amountB;\r\n+        liquidity[msg.sender] += (amountA + amountB);\r\n+    }\r\n+\r\n+    function removeLiquidity(uint256 shares) public {\r\n+        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n+        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n+\r\n+        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n+        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n+\r\n+        reserveA -= amountA;\r\n+        reserveB -= amountB;\r\n+        liquidity[msg.sender] -= shares;\r\n+    }\r\n+\r\n+    function swap(address tokenIn, uint256 amountIn) public returns (uint256 amountOut) {\r\n+        require(amountIn > 0, \"Input amount must be greater than zero\");\r\n+        require(\r\n+            tokenIn == address(tokenA) || tokenIn == address(tokenB),\r\n+            \"Invalid input token\"\r\n+        );\r\n+\r\n+        bool isTokenA = tokenIn == address(tokenA);\r\n+\r\n+        // Reserves of the input and output tokens\r\n+        uint256 reserveIn = isTokenA ? reserveA : reserveB;\r\n+        uint256 reserveOut = isTokenA ? reserveB : reserveA;\r\n+\r\n+        // Apply fee of 0.3% (997/1000)\r\n+        uint256 amountInWithFee = (amountIn * 997) / 1000;\r\n+        amountOut = (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);\r\n+\r\n+        require(amountOut > 0, \"Insufficient output amount\");\r\n+\r\n+        // Transfer the input token from the user to the pool\r\n+        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);\r\n+\r\n+        // Transfer the output token from the pool to the user\r\n+        IERC20 outputToken = isTokenA ? tokenB : tokenA;\r\n+        outputToken.transfer(msg.sender, amountOut);\r\n+\r\n+        // Update reserves\r\n+        if (isTokenA) {\r\n+            reserveA += amountIn;\r\n+            reserveB -= amountOut;\r\n+        } else {\r\n+            reserveB += amountIn;\r\n+            reserveA -= amountOut;\r\n+        }\r\n+    }\r\n+\r\n+    function totalLiquidity() public view returns (uint256) {\r\n+        return reserveA + reserveB;\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1733407544230,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,169 +16,17 @@\n         tokenB = IERC20(_tokenB);\r\n     }\r\n \r\n     function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n-        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA += amountA;\r\n-        reserveB += amountB;\r\n-        liquidity[msg.sender] += (amountA + amountB);\r\n-    }\r\n-\r\n-    function removeLiquidity(uint256 shares) public {\r\n-        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n-        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n-\r\n-        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA -= amountA;\r\n-        reserveB -= amountB;\r\n-        liquidity[msg.sender] -= shares;\r\n-    }\r\n-\r\n-    function swap(address tokenIn, uint256 amountIn) public returns (uint256 amountOut) {\r\n-        require(amountIn > 0, \"Input amount must be greater than zero\");\r\n         require(\r\n-            tokenIn == address(tokenA) || tokenIn == address(tokenB),\r\n-            \"Invalid input token\"\r\n+            tokenA.transferFrom(msg.sender, address(this), amountA),\r\n+            \"Token A transfer failed\"\r\n         );\r\n-\r\n-        bool isTokenA = tokenIn == address(tokenA);\r\n-\r\n-        // Reserves of the input and output tokens\r\n-        uint256 reserveIn = isTokenA ? reserveA : reserveB;\r\n-        uint256 reserveOut = isTokenA ? reserveB : reserveA;\r\n-\r\n-        // Apply fee of 0.3% (997/1000)\r\n-        uint256 amountInWithFee = (amountIn * 997) / 1000;\r\n-        amountOut = (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);\r\n-\r\n-        require(amountOut > 0, \"Insufficient output amount\");\r\n-\r\n-        // Transfer the input token from the user to the pool\r\n-        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);\r\n-\r\n-        // Transfer the output token from the pool to the user\r\n-        IERC20 outputToken = isTokenA ? tokenB : tokenA;\r\n-        outputToken.transfer(msg.sender, amountOut);\r\n-\r\n-        // Update reserves\r\n-        if (isTokenA) {\r\n-            reserveA += amountIn;\r\n-            reserveB -= amountOut;\r\n-        } else {\r\n-            reserveB += amountIn;\r\n-            reserveA -= amountOut;\r\n-        }\r\n-    }\r\n-\r\n-    function totalLiquidity() public view returns (uint256) {\r\n-        return reserveA + reserveB;\r\n-    }\r\n-}\r\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"./IERC20.sol\";\r\n-\r\n-contract LiquidityPool {\r\n-    IERC20 public tokenA;\r\n-    IERC20 public tokenB;\r\n-    mapping(address => uint256) public liquidity;\r\n-\r\n-    uint256 public reserveA;\r\n-    uint256 public reserveB;\r\n-\r\n-    constructor(address _tokenA, address _tokenB) {\r\n-        tokenA = IERC20(_tokenA);\r\n-        tokenB = IERC20(_tokenB);\r\n-    }\r\n-\r\n-    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n-        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA += amountA;\r\n-        reserveB += amountB;\r\n-        liquidity[msg.sender] += (amountA + amountB);\r\n-    }\r\n-\r\n-    function removeLiquidity(uint256 shares) public {\r\n-        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n-        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n-\r\n-        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA -= amountA;\r\n-        reserveB -= amountB;\r\n-        liquidity[msg.sender] -= shares;\r\n-    }\r\n-\r\n-    function swap(address tokenIn, uint256 amountIn) public returns (uint256 amountOut) {\r\n-        require(amountIn > 0, \"Input amount must be greater than zero\");\r\n         require(\r\n-            tokenIn == address(tokenA) || tokenIn == address(tokenB),\r\n-            \"Invalid input token\"\r\n+            tokenB.transferFrom(msg.sender, address(this), amountB),\r\n+            \"Token B transfer failed\"\r\n         );\r\n \r\n-        bool isTokenA = tokenIn == address(tokenA);\r\n-\r\n-        // Reserves of the input and output tokens\r\n-        uint256 reserveIn = isTokenA ? reserveA : reserveB;\r\n-        uint256 reserveOut = isTokenA ? reserveB : reserveA;\r\n-\r\n-        // Apply fee of 0.3% (997/1000)\r\n-        uint256 amountInWithFee = (amountIn * 997) / 1000;\r\n-        amountOut = (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);\r\n-\r\n-        require(amountOut > 0, \"Insufficient output amount\");\r\n-\r\n-        // Transfer the input token from the user to the pool\r\n-        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);\r\n-\r\n-        // Transfer the output token from the pool to the user\r\n-        IERC20 outputToken = isTokenA ? tokenB : tokenA;\r\n-        outputToken.transfer(msg.sender, amountOut);\r\n-\r\n-        // Update reserves\r\n-        if (isTokenA) {\r\n-            reserveA += amountIn;\r\n-            reserveB -= amountOut;\r\n-        } else {\r\n-            reserveB += amountIn;\r\n-            reserveA -= amountOut;\r\n-        }\r\n-    }\r\n-\r\n-    function totalLiquidity() public view returns (uint256) {\r\n-        return reserveA + reserveB;\r\n-    }\r\n-}\r\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"./IER20.sol\";\r\n-\r\n-contract LiquidityPool {\r\n-    IERC20 public tokenA;\r\n-    IERC20 public tokenB;\r\n-    mapping(address => uint256) public liquidity;\r\n-\r\n-    uint256 public reserveA;\r\n-    uint256 public reserveB;\r\n-\r\n-    constructor(address _tokenA, address _tokenB) {\r\n-        tokenA = IERC20(_tokenA);\r\n-        tokenB = IERC20(_tokenB);\r\n-    }\r\n-\r\n-    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n-        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n-\r\n         reserveA += amountA;\r\n         reserveB += amountB;\r\n         liquidity[msg.sender] += (amountA + amountB);\r\n     }\r\n@@ -186,96 +34,26 @@\n     function removeLiquidity(uint256 shares) public {\r\n         uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n         uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n \r\n-        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA -= amountA;\r\n-        reserveB -= amountB;\r\n-        liquidity[msg.sender] -= shares;\r\n-    }\r\n-\r\n-    function swap(address tokenIn, uint256 amountIn) public returns (uint256 amountOut) {\r\n-        require(amountIn > 0, \"Input amount must be greater than zero\");\r\n         require(\r\n-            tokenIn == address(tokenA) || tokenIn == address(tokenB),\r\n-            \"Invalid input token\"\r\n+            tokenA.transfer(msg.sender, amountA),\r\n+            \"Token A transfer failed\"\r\n         );\r\n+        require(\r\n+            tokenB.transfer(msg.sender, amountB),\r\n+            \"Token B transfer failed\"\r\n+        );\r\n \r\n-        bool isTokenA = tokenIn == address(tokenA);\r\n-\r\n-        // Reserves of the input and output tokens\r\n-        uint256 reserveIn = isTokenA ? reserveA : reserveB;\r\n-        uint256 reserveOut = isTokenA ? reserveB : reserveA;\r\n-\r\n-        // Apply fee of 0.3% (997/1000)\r\n-        uint256 amountInWithFee = (amountIn * 997) / 1000;\r\n-        amountOut = (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);\r\n-\r\n-        require(amountOut > 0, \"Insufficient output amount\");\r\n-\r\n-        // Transfer the input token from the user to the pool\r\n-        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);\r\n-\r\n-        // Transfer the output token from the pool to the user\r\n-        IERC20 outputToken = isTokenA ? tokenB : tokenA;\r\n-        outputToken.transfer(msg.sender, amountOut);\r\n-\r\n-        // Update reserves\r\n-        if (isTokenA) {\r\n-            reserveA += amountIn;\r\n-            reserveB -= amountOut;\r\n-        } else {\r\n-            reserveB += amountIn;\r\n-            reserveA -= amountOut;\r\n-        }\r\n-    }\r\n-\r\n-    function totalLiquidity() public view returns (uint256) {\r\n-        return reserveA + reserveB;\r\n-    }\r\n-}\r\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"./IERC20.sol\";\r\n-\r\n-contract LiquidityPool {\r\n-    IERC20 public tokenA;\r\n-    IERC20 public tokenB;\r\n-    mapping(address => uint256) public liquidity;\r\n-\r\n-    uint256 public reserveA;\r\n-    uint256 public reserveB;\r\n-\r\n-    constructor(address _tokenA, address _tokenB) {\r\n-        tokenA = IERC20(_tokenA);\r\n-        tokenB = IERC20(_tokenB);\r\n-    }\r\n-\r\n-    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n-        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA += amountA;\r\n-        reserveB += amountB;\r\n-        liquidity[msg.sender] += (amountA + amountB);\r\n-    }\r\n-\r\n-    function removeLiquidity(uint256 shares) public {\r\n-        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n-        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n-\r\n-        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n-\r\n         reserveA -= amountA;\r\n         reserveB -= amountB;\r\n         liquidity[msg.sender] -= shares;\r\n     }\r\n \r\n-    function swap(address tokenIn, uint256 amountIn) public returns (uint256 amountOut) {\r\n+    function swap(\r\n+        address tokenIn,\r\n+        uint256 amountIn\r\n+    ) public returns (uint256 amountOut) {\r\n         require(amountIn > 0, \"Input amount must be greater than zero\");\r\n         require(\r\n             tokenIn == address(tokenA) || tokenIn == address(tokenB),\r\n             \"Invalid input token\"\r\n@@ -288,9 +66,11 @@\n         uint256 reserveOut = isTokenA ? reserveB : reserveA;\r\n \r\n         // Apply fee of 0.3% (997/1000)\r\n         uint256 amountInWithFee = (amountIn * 997) / 1000;\r\n-        amountOut = (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);\r\n+        amountOut =\r\n+            (reserveOut * amountInWithFee) /\r\n+            (reserveIn + amountInWithFee);\r\n \r\n         require(amountOut > 0, \"Insufficient output amount\");\r\n \r\n         // Transfer the input token from the user to the pool\r\n@@ -313,219 +93,4 @@\n     function totalLiquidity() public view returns (uint256) {\r\n         return reserveA + reserveB;\r\n     }\r\n }\r\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"./IER20.sol\";\r\n-\r\n-contract LiquidityPool {\r\n-    IERC20 public tokenA;\r\n-    IERC20 public tokenB;\r\n-    mapping(address => uint256) public liquidity;\r\n-\r\n-    uint256 public reserveA;\r\n-    uint256 public reserveB;\r\n-\r\n-    constructor(address _tokenA, address _tokenB) {\r\n-        tokenA = IERC20(_tokenA);\r\n-        tokenB = IERC20(_tokenB);\r\n-    }\r\n-\r\n-    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n-        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA += amountA;\r\n-        reserveB += amountB;\r\n-        liquidity[msg.sender] += (amountA + amountB);\r\n-    }\r\n-\r\n-    function removeLiquidity(uint256 shares) public {\r\n-        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n-        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n-\r\n-        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA -= amountA;\r\n-        reserveB -= amountB;\r\n-        liquidity[msg.sender] -= shares;\r\n-    }\r\n-\r\n-    function totalLiquidity() public view returns (uint256) {\r\n-        return reserveA + reserveB;\r\n-    }\r\n-}\r\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"./IER20.sol.sol\";\r\n-\r\n-contract LiquidityPool {\r\n-    IERC20 public tokenA;\r\n-    IERC20 public tokenB;\r\n-    mapping(address => uint256) public liquidity;\r\n-\r\n-    uint256 public reserveA;\r\n-    uint256 public reserveB;\r\n-\r\n-    constructor(address _tokenA, address _tokenB) {\r\n-        tokenA = IERC20(_tokenA);\r\n-        tokenB = IERC20(_tokenB);\r\n-    }\r\n-\r\n-    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n-        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA += amountA;\r\n-        reserveB += amountB;\r\n-        liquidity[msg.sender] += (amountA + amountB);\r\n-    }\r\n-\r\n-    function removeLiquidity(uint256 shares) public {\r\n-        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n-        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n-\r\n-        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA -= amountA;\r\n-        reserveB -= amountB;\r\n-        liquidity[msg.sender] -= shares;\r\n-    }\r\n-\r\n-    function totalLiquidity() public view returns (uint256) {\r\n-        return reserveA + reserveB;\r\n-    }\r\n-}\r\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"./IERC20.sol\";\r\n-\r\n-contract LiquidityPool {\r\n-    IERC20 public tokenA;\r\n-    IERC20 public tokenB;\r\n-    mapping(address => uint256) public liquidity;\r\n-\r\n-    uint256 public reserveA;\r\n-    uint256 public reserveB;\r\n-\r\n-    constructor(address _tokenA, address _tokenB) {\r\n-        tokenA = IERC20(_tokenA);\r\n-        tokenB = IERC20(_tokenB);\r\n-    }\r\n-\r\n-    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n-        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA += amountA;\r\n-        reserveB += amountB;\r\n-        liquidity[msg.sender] += (amountA + amountB);\r\n-    }\r\n-\r\n-    function removeLiquidity(uint256 shares) public {\r\n-        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n-        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n-\r\n-        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA -= amountA;\r\n-        reserveB -= amountB;\r\n-        liquidity[msg.sender] -= shares;\r\n-    }\r\n-\r\n-    function totalLiquidity() public view returns (uint256) {\r\n-        return reserveA + reserveB;\r\n-    }\r\n-}\r\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"./src/contract/IERC20.sol\";\r\n-\r\n-contract LiquidityPool {\r\n-    IERC20 public tokenA;\r\n-    IERC20 public tokenB;\r\n-    mapping(address => uint256) public liquidity;\r\n-\r\n-    uint256 public reserveA;\r\n-    uint256 public reserveB;\r\n-\r\n-    constructor(address _tokenA, address _tokenB) {\r\n-        tokenA = IERC20(_tokenA);\r\n-        tokenB = IERC20(_tokenB);\r\n-    }\r\n-\r\n-    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n-        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA += amountA;\r\n-        reserveB += amountB;\r\n-        liquidity[msg.sender] += (amountA + amountB);\r\n-    }\r\n-\r\n-    function removeLiquidity(uint256 shares) public {\r\n-        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n-        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n-\r\n-        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA -= amountA;\r\n-        reserveB -= amountB;\r\n-        liquidity[msg.sender] -= shares;\r\n-    }\r\n-\r\n-    function totalLiquidity() public view returns (uint256) {\r\n-        return reserveA + reserveB;\r\n-    }\r\n-}\r\n-// SPDX-License-Identifier: MIT\r\n-pragma solidity ^0.8.0;\r\n-\r\n-import \"./src//IERC20.sol\";\r\n-\r\n-contract LiquidityPool {\r\n-    IERC20 public tokenA;\r\n-    IERC20 public tokenB;\r\n-    mapping(address => uint256) public liquidity;\r\n-\r\n-    uint256 public reserveA;\r\n-    uint256 public reserveB;\r\n-\r\n-    constructor(address _tokenA, address _tokenB) {\r\n-        tokenA = IERC20(_tokenA);\r\n-        tokenB = IERC20(_tokenB);\r\n-    }\r\n-\r\n-    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n-        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA += amountA;\r\n-        reserveB += amountB;\r\n-        liquidity[msg.sender] += (amountA + amountB);\r\n-    }\r\n-\r\n-    function removeLiquidity(uint256 shares) public {\r\n-        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n-        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n-\r\n-        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n-        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n-\r\n-        reserveA -= amountA;\r\n-        reserveB -= amountB;\r\n-        liquidity[msg.sender] -= shares;\r\n-    }\r\n-\r\n-    function totalLiquidity() public view returns (uint256) {\r\n-        return reserveA + reserveB;\r\n-    }\r\n-}\r\n"
                }
            ],
            "date": 1733405990047,
            "name": "Commit-0",
            "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./src//IERC20.sol\";\r\n\r\ncontract LiquidityPool {\r\n    IERC20 public tokenA;\r\n    IERC20 public tokenB;\r\n    mapping(address => uint256) public liquidity;\r\n\r\n    uint256 public reserveA;\r\n    uint256 public reserveB;\r\n\r\n    constructor(address _tokenA, address _tokenB) {\r\n        tokenA = IERC20(_tokenA);\r\n        tokenB = IERC20(_tokenB);\r\n    }\r\n\r\n    function addLiquidity(uint256 amountA, uint256 amountB) public {\r\n        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Token A transfer failed\");\r\n        require(tokenB.transferFrom(msg.sender, address(this), amountB), \"Token B transfer failed\");\r\n\r\n        reserveA += amountA;\r\n        reserveB += amountB;\r\n        liquidity[msg.sender] += (amountA + amountB);\r\n    }\r\n\r\n    function removeLiquidity(uint256 shares) public {\r\n        uint256 amountA = (shares * reserveA) / totalLiquidity();\r\n        uint256 amountB = (shares * reserveB) / totalLiquidity();\r\n\r\n        require(tokenA.transfer(msg.sender, amountA), \"Token A transfer failed\");\r\n        require(tokenB.transfer(msg.sender, amountB), \"Token B transfer failed\");\r\n\r\n        reserveA -= amountA;\r\n        reserveB -= amountB;\r\n        liquidity[msg.sender] -= shares;\r\n    }\r\n\r\n    function totalLiquidity() public view returns (uint256) {\r\n        return reserveA + reserveB;\r\n    }\r\n}\r\n"
        }
    ]
}